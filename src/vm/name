free.c:      if (hero->name)
free.c:	free(hero->name);
free.c:      if (hero->comment)
free.c:	free(hero->comment);
free.c:      if (hero->data)
free.c:	free(hero->data);
free.c:      freeInst(hero->inst);
free.c:      hero = hero->next;
case/zjmp_case.c:  if (hero->carry)
case/zjmp_case.c:      hero->pc = (ABS(sum)) % MEM_SIZE;
case/zjmp_case.c:      my_write_nb(hero->pc, 1, 1);
case/ldi_case.c:	 (tmp[i + 2] = map[(hero->loadAddress + new->pcSave + i + new->args[0])
case/ldi_case.c:  tmp = (char *)&hero->reg[new->args[2] % REG_SIZE];
case/ldi_case.c:		     map[(hero->loadAddress + new->pcSave + i + s) %
case/ldi_case.c:  (hero->reg[new->args[2] % REG_SIZE]) ?
case/ldi_case.c:    (hero->carry = true) : (hero->carry = false);
case/add_case.c:  hero->reg[new->args[2] % REG_SIZE] = new->args[0] + new->args[1];
case/add_case.c:  (hero->reg[new->args[2] % REG_SIZE]) ?
case/add_case.c:    (hero->carry = true) : (hero->carry = false);
case/live_case.c:  playerAlive(hero->id, hero->name);
case/live_case.c:  if (hero->reg[0] == (unsigned int)new->args[0])
case/live_case.c:      hero->isAlive = true;
case/or_case.c:  hero->reg[new->args[2] % REG_SIZE] = new->args[0] | new->args[1];
case/or_case.c:  (hero->reg[new->args[2] % REG_SIZE]) ?
case/or_case.c:    (hero->carry = true) : (hero->carry = false);
case/sub_case.c:  hero->reg[new->args[2] % REG_SIZE] = new->args[0] - new->args[1];
case/sub_case.c:  (hero->reg[new->args[2] % REG_SIZE]) ?
case/sub_case.c:    (hero->carry = true) : (hero->carry = false);
case/ld_case.c:  tmp = (char *)&hero->reg[new->args[1] % REG_SIZE];
case/ld_case.c:	  map[(hero->loadAddress + new->args[2] +
case/ld_case.c:    hero->reg[new->args[1] % REG_SIZE] %= IDX_MOD;
case/ld_case.c:  (hero->reg[new->args[1] % REG_SIZE]) ?
case/ld_case.c:    (hero->carry = true) : (hero->carry = false);
case/fork_case.c:  new->reg[0] = hero->reg[0];
case/fork_case.c:  new->reg[1] = hero->reg[1];
case/fork_case.c:  new->reg[2] = hero->reg[2];
case/fork_case.c:  new->reg[3] = hero->reg[3];
case/fork_case.c:  new->reg[4] = hero->reg[4];
case/fork_case.c:  new->reg[5] = hero->reg[5];
case/fork_case.c:      !(newHero->name = my_strdup(hero->name)))
case/fork_case.c:  newHero->id = hero->id;
case/fork_case.c:  newHero->loadAddress = hero->loadAddress;
case/fork_case.c:  newHero->pc = (hero->loadAddress + hero->pc + new->args[0]) % IDX_MOD;
case/fork_case.c:  newHero->size = hero->size;
case/fork_case.c:  newHero->customId = hero->customId;
case/fork_case.c:  newHero->customAddress = hero->customAddress;
case/fork_case.c:  newHero->isAlive = hero->isAlive;
case/fork_case.c:  newHero->carry = hero->carry;
case/fork_case.c:  newHero->next = hero->next;
case/fork_case.c:  hero->next = newHero;
case/load/zjmp_case.c:  new->args[1] = hero->pc % MEM_SIZE;
case/load/sti_case.c:    map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/sti_case.c:    hero->reg[(map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/sti_case.c:	  hero->reg[(map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/lldi_case.c:  new->pcSave = hero->pc;
case/load/lldi_case.c:    map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/lldi_case.c:	  hero->reg[(map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/lldi_case.c:  new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/ldi_case.c:  new->pcSave = hero->pc;
case/load/ldi_case.c:    map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/ldi_case.c:	  hero->reg[(map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/ldi_case.c:  new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/add_case.c:  new->bytecode = ++hero->pc;
case/load/add_case.c:  new->args[0] = hero->reg[(map[(hero->loadAddress + hero->pc++)
case/load/add_case.c:  new->args[1] = hero->reg[(map[(hero->loadAddress + hero->pc++)
case/load/add_case.c:  new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/lld_case.c:  new->args[2] = hero->pc;
case/load/lld_case.c:    map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/lld_case.c:  new->args[1] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE]  - 1)
case/load/ld_case.c:  new->args[2] = hero->pc;
case/load/ld_case.c:    map[(hero->loadAddress + hero->pc++) % MEM_SIZE] % IDX_MOD;
case/load/ld_case.c:  new->args[1] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE]  - 1)
case/load/and_case.c:    map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/and_case.c:	  hero->reg[(map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/and_case.c:  new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/st_case.c:  new->args[2] = hero->pc;
case/load/st_case.c:    map[(hero->loadAddress + hero->pc++) % MEM_SIZE] % IDX_MOD;
case/load/st_case.c:    hero->reg[(map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/st_case.c:      new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE]
case/load/aff_case.c:  new->bytecode = map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/aff_case.c:  new->args[0] = map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1;
case/xor_case.c:  hero->reg[new->args[2] % REG_SIZE] = new->args[0] ^ new->args[1];
case/xor_case.c:  (hero->reg[new->args[2] % REG_SIZE]) ?
case/xor_case.c:    (hero->carry = true) : (hero->carry = false);
case/and_case.c:  hero->reg[new->args[2] % REG_SIZE] = new->args[0] & new->args[1];
case/and_case.c:  (hero->reg[new->args[2] % REG_SIZE]) ?
case/and_case.c:    (hero->carry = true) : (hero->carry = false);
case/st_case.c:    hero->reg[new->args[2] % REG_SIZE] = new->args[0];
case/st_case.c:	     (map[(hero->loadAddress + new->args[2] +
case/aff_case.c:  c = (unsigned char)hero->reg[new->args[0]] % 256;
case/lfork_case.c:      !(newHero->name = my_strdup(hero->name)) ||
case/lfork_case.c:      !(newHero->comment = my_strdup(hero->comment)))
case/lfork_case.c:  newHero->id = hero->id;
case/lfork_case.c:  newHero->loadAddress = hero->loadAddress;
case/lfork_case.c:  newHero->pc = (hero->loadAddress + hero->pc + new->args[0]);
case/lfork_case.c:  newHero->size = hero->size;
case/lfork_case.c:  newHero->customId = hero->customId;
case/lfork_case.c:  newHero->customAddress = hero->customAddress;
case/lfork_case.c:  newHero->isAlive = hero->isAlive;
case/lfork_case.c:  newHero->carry = hero->carry;
case/lfork_case.c:  newHero->next = hero->next;
case/lfork_case.c:  hero->next = newHero;
exec.c:	  printf("hero->name = %s\n", heros->comment);
init.c:  new->id = hero->id + 1;
init.c:  hero->reg[0] = hero->id;
init.c:  hero->next = new;
init.c:  hero->id = 1;
init.c:  hero->loadAddress = -1;
init.c:  hero->name = NULL;
init.c:  hero->comment = NULL;
init.c:  hero->pc = 0;
init.c:  hero->size = 0;
init.c:  hero->customId = false;
init.c:  hero->customAddress = false;
init.c:  hero->carry = false;
init.c:  hero->reg[0] = hero->id;
init.c:  hero->isAlive = false;
init.c:  hero->inst = NULL;
init.c:  hero->next = NULL;
init.c:  while (++i < hero->size)
init.c:      map[(hero->loadAddress + i) % MEM_SIZE] = hero->data[i];
value.c:	 (tmp[i] = map[(hero->loadAddress + hero->pc + i) % MEM_SIZE], 1));
value.c:  hero->pc += 4;
value.c:	 (tmp[i] = map[(hero->loadAddress + hero->pc + i) % MEM_SIZE], 1));
value.c:  hero->pc += 2;

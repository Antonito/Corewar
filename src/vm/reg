free.c:      if (hero->name)
free.c:	free(hero->name);
free.c:      if (hero->comment)
free.c:	free(hero->comment);
free.c:      if (hero->data)
free.c:	free(hero->data);
free.c:      freeInst(hero->inst);
free.c:      hero = hero->next;
case/ldiCase.c:	 (tmp[i] = map[(hero->loadAddress + hero->pc + i) % MEM_SIZE]) > -1);
case/ldiCase.c:  hero->reg[new->args[2] % REG_SIZE] =
case/ldiCase.c:    map[(hero->loadAddress + hero->pc + s) % MEM_SIZE];
case/ldiCase.c:  (hero->reg[new->args[2] % REG_SIZE]) ?
case/ldiCase.c:    (hero->carry = true) : (hero->carry = false);
case/orCase.c:  hero->reg[new->args[2]] = new->args[0] | new->args[1];
case/orCase.c:  (hero->reg[new->args[2]]) ? (hero->carry = true) : (hero->carry = false);
case/subCase.c:  hero->reg[new->args[2]] = new->args[0] - new->args[1];
case/subCase.c:  (hero->reg[new->args[2]]) ? (hero->carry = true) : (hero->carry = false);
case/xorCase.c:  hero->reg[new->args[2]] = new->args[0] ^ new->args[1];
case/xorCase.c:  (hero->reg[new->args[2]]) ? (hero->carry = true) : (hero->carry = false);
case/zjmpCase.c:  if (hero->carry)
case/zjmpCase.c:      hero->pc = (new->args[1] + new->args[0]) % MEM_SIZE;
case/zjmpCase.c:      my_write_nb(hero->pc, 1, 1);
case/load/stiCase.c:  byte.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/stiCase.c:  new->args[0] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/stiCase.c:	hero->reg[((map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/lldCase.c:  code.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/lldCase.c:	  hero->reg[(((int)map[(hero->loadAddress + hero->pc++) % MEM_SIZE])
case/load/affCase.c:  byte.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/affCase.c:      hero->reg[((map[(hero->loadAddress + hero->pc++) % MEM_SIZE]
case/load/lldiCase.c:  byte.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/lldiCase.c:	  hero->reg[((map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/lldiCase.c:  new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/ldiCase.c:  byte.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/ldiCase.c:	  hero->reg[((map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/ldiCase.c:  new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/zjmpCase.c:  new->args[1] = hero->pc;
case/load/addCase.c:  code.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE]
case/load/addCase.c:	  hero->reg[(((int)map[(hero->loadAddress + hero->pc++) % MEM_SIZE])
case/load/addCase.c:	new->args[i] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/stCase.c:  code.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE]
case/load/stCase.c:    hero->reg[(((int)map[(hero->loadAddress + hero->pc++) % MEM_SIZE]) - 1)
case/load/stCase.c:      new->args[2] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/ldCase.c:  code.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE]
case/load/ldCase.c:    new->args[0] = hero->reg[((map[(hero->loadAddress + hero->pc++)
case/load/ldCase.c:  new->args[1] = (map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1)
case/load/andCase.c:  byte.bytecode = (char)map[(hero->loadAddress + hero->pc++) % MEM_SIZE];
case/load/andCase.c:	new->args[i] = hero->reg[((map[(hero->loadAddress + hero->pc++)
case/load/andCase.c:	new->args[2] = map[(hero->loadAddress + hero->pc++) % MEM_SIZE] - 1;
case/addCase.c:  hero->reg[new->args[2]] = new->args[0] + new->args[1];
case/addCase.c:  (hero->reg[new->args[2]]) ? (hero->carry = true) : (hero->carry = false);
case/stCase.c:    new->args[1] = hero->reg[new->args[2]];
case/stCase.c:  map[(hero->loadAddress + hero->pc + new->args[0]) % MEM_SIZE] = new->args[1];
case/ldCase.c:  hero->reg[new->args[1]] = new->args[0];
case/ldCase.c:  (hero->reg[new->args[1]]) ? (hero->carry = true) : (hero->carry = false);
case/andCase.c:  hero->reg[new->args[2]] = new->args[0] & new->args[1];
case/andCase.c:  (hero->reg[new->args[2]]) ? (hero->carry = true) : (hero->carry = false);
init.c:  new->id = hero->id + 1;
init.c:  hero->next = new;
init.c:  hero->id = 1;
init.c:  hero->loadAddress = -1;
init.c:  hero->name = NULL;
init.c:  hero->comment = NULL;
init.c:  hero->pc = 0;
init.c:  hero->size = 0;
init.c:  hero->customId = false;
init.c:  hero->customAddress = false;
init.c:  hero->carry = false;
init.c:  hero->isAlive = true;
init.c:  hero->inst = NULL;
init.c:  hero->next = NULL;
init.c:  while (++i < hero->size)
init.c:      map[hero->loadAddress + i] = hero->data[i];
value.c:	 (tmp[i] = map[(hero->loadAddress + hero->pc + i) % MEM_SIZE]) > -1);
value.c:  hero->pc += 4;
value.c:	 (tmp[i] = map[(hero->loadAddress + hero->pc + i) % MEM_SIZE]) > -1);
value.c:  hero->pc += 2;
